---
phase: 02-core-interface
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/cli/index.tsx
  - src/ui/components/MessageItem.tsx
  - src/ui/components/ConversationView.tsx
  - src/ui/components/InputPrompt.tsx
  - src/ui/components/StatusBar.tsx
  - src/cli/app.tsx
autonomous: true

must_haves:
  truths:
    - "Running `vec` launches TUI with status bar and input prompt"
    - "Messages display with role distinction (user vs assistant) and timestamps"
    - "User can type text and submit with Enter"
    - "Status bar shows workspace name and current mode"
    - "Conversation view windows messages to fit terminal height"
  artifacts:
    - path: "src/cli/index.tsx"
      provides: "CLI entry point with meow arg parsing"
      contains: "meow"
    - path: "src/cli/app.tsx"
      provides: "Root Ink App component"
      exports: ["App"]
    - path: "src/ui/components/ConversationView.tsx"
      provides: "Message list with windowing"
      exports: ["ConversationView"]
    - path: "src/ui/components/InputPrompt.tsx"
      provides: "Text input with Enter submission"
      exports: ["InputPrompt"]
  key_links:
    - from: "src/cli/index.tsx"
      to: "src/cli/app.tsx"
      via: "render(<App>)"
      pattern: "render.*App"
    - from: "src/cli/app.tsx"
      to: "src/ui/components/ConversationView.tsx"
      via: "JSX composition"
      pattern: "<ConversationView"
    - from: "src/cli/app.tsx"
      to: "src/workspace/WorkspaceManager.ts"
      via: "Workspace resolution on startup"
      pattern: "WorkspaceManager"
---

<objective>
Build the CLI entry point and all Ink UI components for the conversation interface.

Purpose: Creates the visual layer users interact with. After this plan, `vec` launches and renders a TUI with message display, input prompt, and status bar -- but without streaming (that's Plan 03).
Output: CLI entry point with workspace flag parsing, root App component, and all UI subcomponents.
</objective>

<execution_context>
@/Users/enw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/enw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-interface/02-CONTEXT.md
@.planning/phases/02-core-interface/02-RESEARCH.md
@.planning/phases/02-core-interface/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: CLI entry point with arg parsing</name>
  <files>src/cli/index.tsx</files>
  <action>
Create `src/cli/index.tsx` as the main entry point:

Use meow for CLI argument parsing:
```
Usage: vec [options]

Options:
  -w, --workspace <name>  Create or switch to named workspace
  -w, --workspace         Create numbered workspace (auto-increment)
  --version               Show version
  --help                  Show help
```

Workspace resolution logic:
1. If `-w some-name` provided: use that name (getOrCreate)
2. If `-w` provided without value: createNumbered()
3. If no flag: getLastActive(), if null then createNumbered() as default

Import WorkspaceManager from `../workspace/index.js`. Call `ensureDirectories()` first.

Resolve workspace, then `render(<App workspaceName={name} workspacePath={path} />)` using Ink's render.

Add package.json `"bin"` field pointing to `./dist/cli/index.js` for the `vec` command. (Note: you'll need to update package.json to add the bin field.)

Also add a shebang `#!/usr/bin/env node` at top of the file.

Handle errors at top level with try/catch, print error message, exit(1).
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes. File structure correct.
  </verify>
  <done>CLI entry point parses -w flag, resolves workspace, launches Ink app.</done>
</task>

<task type="auto">
  <name>Task 2: UI components</name>
  <files>src/ui/components/MessageItem.tsx, src/ui/components/ConversationView.tsx, src/ui/components/InputPrompt.tsx, src/ui/components/StatusBar.tsx</files>
  <action>
Create four UI components following Ink patterns from RESEARCH.md:

**MessageItem.tsx:**
- Props: `{ message: Message }`
- Display: role indicator ("> " for user cyan bold, "< " for assistant green bold), timestamp (HH:MM format from message.timestamp), content
- If message.cancelled, append " [cancelled]" in yellow
- Wrap content in `<Box>` with `marginBottom={0}`

**ConversationView.tsx:**
- Props: `{ messages: Message[]; streamingContent?: string }`
- Use `useStdoutDimensions()` for terminal height
- Window visible messages: `messages.slice(-Math.max(10, availableRows))` where availableRows = rows - 4 (status bar + input area)
- Use Ink `<Static>` for rendered message history (as per research pattern)
- If streamingContent provided, render it below history with assistant styling and ink-spinner while streaming
- Handle empty state: show "No messages yet. Type a message to begin." in dim text

**InputPrompt.tsx:**
- Props: `{ onSubmit: (text: string) => void; disabled?: boolean }`
- Use ink-text-input for text entry
- On submit (Enter), call onSubmit with trimmed text, clear input
- When disabled (during streaming), show grayed-out input or hide text-input
- Show "> " prefix before input area

**StatusBar.tsx:**
- Props: `{ workspaceName: string; mode: 'tui' | 'cli'; isStreaming: boolean }`
- Render at top of screen
- Show: workspace name, mode indicator, streaming status
- Use `<Box borderStyle="single" paddingX={1}>` for visual separation
- Format: `[workspace-name] | TUI | Streaming...` or `[workspace-name] | TUI | Ready`
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes. All components export correctly.
  </verify>
  <done>All four UI components created with correct props and rendering logic.</done>
</task>

<task type="auto">
  <name>Task 3: Root App component</name>
  <files>src/cli/app.tsx</files>
  <action>
Create `src/cli/app.tsx` as the root Ink component:

Props: `{ workspaceName: string; workspacePath: string }`

Layout (top to bottom):
1. StatusBar (top)
2. ConversationView (fills available space)
3. InputPrompt (bottom)

Use `<Box flexDirection="column" height="100%">` for full-screen layout.

State management (local useState for now, hooks come in Plan 04):
- `messages: Message[]` -- loaded from ConversationStore on mount
- `streamingContent: string` -- current streaming response text (empty string = not streaming)
- `isStreaming: boolean` -- whether currently streaming

On mount (useEffect):
- Create ConversationStore for workspacePath
- Load existing messages via store.loadAll()
- Set messages state

On submit from InputPrompt:
- Create user Message object (generate id with crypto.randomUUID(), timestamp Date.now())
- Append to messages state
- Append to ConversationStore
- Set isStreaming = true (actual streaming wired in Plan 04)
- For now: after 500ms timeout, create a placeholder assistant message "Streaming not yet connected. See Plan 03/04." and append it. Set isStreaming = false.

Mode detection:
- Check `process.stdout.isTTY` and `process.stdout.columns` -- if TTY with columns, mode = 'tui', else mode = 'cli'

This creates a working but non-streaming app. Plans 03+04 replace the placeholder with real Anthropic streaming.
  </action>
  <verify>
`pnpm exec tsc --noEmit` passes. `pnpm build` succeeds. Running `node dist/cli/index.js` launches the TUI (may need ANTHROPIC_API_KEY later, but basic UI should render).
  </verify>
  <done>Root App component renders full TUI layout, loads workspace messages on mount, handles user input with placeholder responses.</done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit` -- zero errors
- `pnpm build` -- compiles all TSX to JS
- `node dist/cli/index.js --help` shows usage
- `node dist/cli/index.js -w test-workspace` launches TUI
- UI renders: status bar, empty conversation view, input prompt
</verification>

<success_criteria>
- CLI parses workspace flags correctly
- TUI launches with full-screen Ink layout
- All UI components render without errors
- User can type and submit messages (placeholder responses)
- Workspace created on disk, messages persisted to JSONL
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-interface/02-02-SUMMARY.md`
</output>
