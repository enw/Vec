---
phase: 01-security-and-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/permission/engine.ts
  - src/permission/rules.ts
  - src/permission/prompts.ts
  - src/permission/index.ts
autonomous: true

must_haves:
  truths:
    - "Permission engine blocks sensitive operations without matching rule or explicit approval"
    - "Approved rules are persisted to config and auto-applied on subsequent checks"
    - "All permission decisions are audit logged"
  artifacts:
    - path: "src/permission/engine.ts"
      provides: "Core permission evaluation logic"
      exports: ["PermissionEngine"]
      min_lines: 50
    - path: "src/permission/rules.ts"
      provides: "Rule matching with glob patterns"
      exports: ["matchRule", "addRule", "removeRule"]
    - path: "src/permission/prompts.ts"
      provides: "User-facing approval prompt interface"
      exports: ["promptForPermission"]
  key_links:
    - from: "src/permission/engine.ts"
      to: "src/config/loader.ts"
      via: "loads and saves rules through config"
      pattern: "(loadConfig|saveConfig)"
    - from: "src/permission/engine.ts"
      to: "src/audit/logger.ts"
      via: "logs all permission decisions"
      pattern: "auditEvent|permissionLogger"
    - from: "src/permission/rules.ts"
      to: "minimatch"
      via: "glob pattern matching for rules"
      pattern: "minimatch"
---

<objective>
Implement the permission engine that gates all sensitive operations (SEC-01). Uses hybrid approval flow: check rules first, prompt user if no match, offer to create rule after approval.

Purpose: This is Vec's core security mechanism -- the system that prevents autonomous data leaks by requiring explicit user consent for sensitive actions.
Output: PermissionEngine class with rule matching, user prompting, and audit integration.
</objective>

<execution_context>
@/Users/enw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/enw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-and-foundation/01-RESEARCH.md
@.planning/phases/01-security-and-foundation/01-CONTEXT.md
@.planning/phases/01-security-and-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rule matching and storage</name>
  <files>src/permission/rules.ts</files>
  <action>
    1. Create src/permission/rules.ts:
       - `matchRule(action: PermissionAction, target: string, rules: PermissionRule[]): PermissionRule | null`
         - Iterate rules, find first where rule.action matches AND minimatch(target, rule.pattern) is true
         - Skip expired rules (check expiresAt vs current time)
         - Return matching rule or null
       - `addRule(rules: PermissionRule[], newRule: Omit<PermissionRule, 'id' | 'createdAt'>): PermissionRule[]`
         - Generate UUID id, set createdAt to now
         - Validate with PermissionRuleSchema.parse()
         - Return [...rules, validatedRule]
       - `removeRule(rules: PermissionRule[], ruleId: string): PermissionRule[]`
         - Filter out rule with matching id
       - `isExpired(rule: PermissionRule): boolean`
         - If no expiresAt, return false. Otherwise compare to Date.now()
    2. Import types from src/types.ts and schemas from src/config/schema.ts
    3. Use minimatch for glob pattern matching (import from 'minimatch')
  </action>
  <verify>Run `pnpm exec tsc --noEmit` passes</verify>
  <done>Rule matching works with glob patterns, expired rules skipped, rules can be added/removed</done>
</task>

<task type="auto">
  <name>Task 2: Permission engine with hybrid approval flow</name>
  <files>src/permission/engine.ts, src/permission/prompts.ts, src/permission/index.ts</files>
  <action>
    1. Create src/permission/prompts.ts:
       - Define `ApprovalResponse` interface: { approved: boolean, createRule: boolean, rulePattern?: string }
       - Define `PermissionPromptFn` type: (action: PermissionAction, target: string, context?: string) => Promise<ApprovalResponse>
       - Export `defaultPromptFn`: a basic implementation that auto-denies (for non-interactive/testing contexts). In interactive mode, consumers will inject their own prompt function.
       - Export `formatPermissionPrompt(action: PermissionAction, target: string, verbosity: 'minimal' | 'detailed' | 'custom'): string` that formats human-readable prompt text
         - minimal: "Allow {action} on {target}? [y/N/r(ule)]"
         - detailed: includes explanation of what the action does and risk level
    2. Create src/permission/engine.ts:
       - `PermissionEngine` class:
         - Constructor takes: `{ config: PermissionConfig, promptFn?: PermissionPromptFn }`
         - Store config, promptFn (default to defaultPromptFn), create permissionLogger child
         - `async check(action: PermissionAction, target: string): Promise<boolean>`
           a. Call matchRule() against config.rules
           b. If rule found and approved: audit log "auto-approved", return true
           c. If rule found and not approved: audit log "auto-denied", return false
           d. If no rule: call promptFn() for user decision
           e. If user approves and createRule: call addRule(), saveConfig()
           f. Audit log the decision either way
           g. Return approved boolean
         - `async checkOrThrow(action: PermissionAction, target: string): Promise<void>`
           - Calls check(), throws PermissionDeniedError if false
         - `getRules(): PermissionRule[]` -- return current rules
         - `async removeRule(ruleId: string): Promise<void>` -- remove and save
       - Export `PermissionDeniedError` class extending Error with action and target properties
    3. Create src/permission/index.ts: re-export all from engine, rules, prompts
  </action>
  <verify>Run `pnpm exec tsc --noEmit` passes. All exports resolve correctly.</verify>
  <done>PermissionEngine checks rules, prompts user, persists new rules, and audit logs every decision. Hybrid approval flow complete per SEC-01.</done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit` passes
- PermissionEngine can be instantiated with default config
- check() returns false when no rules and default (auto-deny) prompt
- Rules can be added and matched by glob pattern
- All permission decisions produce audit log entries
</verification>

<success_criteria>
- PermissionEngine blocks operations without explicit approval (SEC-01 core)
- Hybrid flow: rules checked first, then prompt, then optional rule creation
- Glob-based rule matching (e.g., "/tmp/*" matches "/tmp/foo.txt")
- Expired rules automatically skipped
- Every decision audit-logged via Pino
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-and-foundation/01-02-SUMMARY.md`
</output>
