---
phase: 01-security-and-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/validation/classifier.ts
  - src/validation/schemas.ts
  - src/validation/sanitizer.ts
  - src/validation/index.ts
autonomous: true

must_haves:
  truths:
    - "System classifies input as trusted or untrusted based on source"
    - "Only validated input can be promoted from untrusted to trusted"
    - "Zod schemas enforce validation at every trust boundary"
  artifacts:
    - path: "src/validation/classifier.ts"
      provides: "Input source classification with branded types"
      exports: ["classifyInput", "isTrusted"]
    - path: "src/validation/schemas.ts"
      provides: "Zod schemas for common input types"
      exports: ["UserCommandSchema", "FileContentSchema"]
    - path: "src/validation/sanitizer.ts"
      provides: "Sanitization that promotes untrusted to trusted"
      exports: ["sanitize", "sanitizeFileContent"]
  key_links:
    - from: "src/validation/classifier.ts"
      to: "src/types.ts"
      via: "uses TrustedInput, UntrustedInput, InputSource types"
      pattern: "(TrustedInput|UntrustedInput|InputSource)"
    - from: "src/validation/sanitizer.ts"
      to: "zod"
      via: "Zod schema validation for promotion"
      pattern: "z\\.(string|object|parse)"
---

<objective>
Implement input classification and validation system (SEC-02). Classifies all input by source (user command vs external content) and enforces Zod validation at trust boundaries.

Purpose: Prevents untrusted input from reaching sensitive operations without validation. Uses TypeScript branded types for compile-time safety plus Zod for runtime enforcement.
Output: Classifier, schemas, and sanitizer modules for the validation subsystem.
</objective>

<execution_context>
@/Users/enw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/enw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-and-foundation/01-RESEARCH.md
@.planning/phases/01-security-and-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Input classifier with branded types</name>
  <files>src/validation/classifier.ts</files>
  <action>
    1. Create src/validation/classifier.ts:
       - Import TrustedInput, UntrustedInput, InputSource from src/types.ts
       - Import validationLogger from src/audit/logger.ts
       - Define trust map: Record<InputSource, boolean>
         - USER_COMMAND: true (direct CLI input from user)
         - FILE_CONTENT: false (may contain injected content)
         - NETWORK: false (external API responses)
         - ENVIRONMENT: false (env vars may be manipulated)
       - `classifyInput(input: string, source: InputSource): TrustedInput | UntrustedInput`
         - Look up trust status in trustMap
         - Log classification at debug level
         - Return branded type based on trust status
       - `isTrusted(input: TrustedInput | UntrustedInput): input is TrustedInput`
         - Type guard function. Since branded types are compile-time only, this checks if the input was produced via trusted classification. Implementation: maintain a WeakSet or use a Symbol property to track trusted values at runtime.
         - Better approach: use a wrapper object `{ value: string, trusted: boolean, source: InputSource }` internally, with branded type getters. This avoids runtime tracking complexity.
       - Actually, simplest correct approach: Export a `ClassifiedInput` type that wraps the value with metadata:
         ```
         interface ClassifiedInput {
           value: string
           source: InputSource
           trusted: boolean
         }
         ```
         AND keep the branded types for function signatures that require trusted input.
       - `classifyInput(input: string, source: InputSource): ClassifiedInput`
       - `asTrusted(classified: ClassifiedInput): TrustedInput` -- only works if classified.trusted is true, throws otherwise
       - `asUntrusted(classified: ClassifiedInput): UntrustedInput` -- wraps as untrusted
  </action>
  <verify>Run `pnpm exec tsc --noEmit`</verify>
  <done>Input classifier correctly brands input by source. USER_COMMAND is trusted, all others untrusted. Runtime metadata tracks trust status.</done>
</task>

<task type="auto">
  <name>Task 2: Validation schemas and sanitizer</name>
  <files>src/validation/schemas.ts, src/validation/sanitizer.ts, src/validation/index.ts</files>
  <action>
    1. Create src/validation/schemas.ts:
       - `UserCommandSchema` = z.string().min(1).max(10000).trim() -- user CLI commands
       - `FilePathSchema` = z.string().min(1).max(4096).refine(path => !path.includes('\0'), 'Null bytes not allowed in paths')
       - `FileContentSchema` = z.string().max(10_000_000) -- 10MB max
       - `NetworkResponseSchema` = z.object({ status: z.number(), body: z.string().max(10_000_000) })
       - `EnvironmentVarSchema` = z.string().max(32768) -- env var length limit
       - Export all schemas
    2. Create src/validation/sanitizer.ts:
       - Import schemas from schemas.ts, types from types.ts, classifier from classifier.ts
       - `sanitize<T>(input: UntrustedInput, schema: z.ZodSchema<T>): T`
         - Uses schema.parse(input) -- throws ZodError on invalid
         - Returns validated value
       - `safeSanitize<T>(input: UntrustedInput, schema: z.ZodSchema<T>): { success: true, data: T } | { success: false, error: z.ZodError }`
         - Uses schema.safeParse(input)
       - `sanitizeAndTrust(input: ClassifiedInput, schema: z.ZodSchema<string>): TrustedInput`
         - Validates with schema, returns as TrustedInput branded type
         - This is THE function that promotes untrusted -> trusted after validation
       - `sanitizeFileContent(content: string): TrustedInput`
         - Shorthand: classify as FILE_CONTENT, validate with FileContentSchema, return trusted
       - `sanitizeFilePath(path: string): TrustedInput`
         - Classify as FILE_CONTENT, validate with FilePathSchema, resolve symlinks warning (log if symlink detected), return trusted
    3. Create src/validation/index.ts: re-export all from classifier, schemas, sanitizer
  </action>
  <verify>Run `pnpm exec tsc --noEmit`</verify>
  <done>Zod schemas validate all input types. Sanitizer promotes untrusted -> trusted only after validation. Trust boundary enforcement complete per SEC-02.</done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit` passes
- classifyInput('hello', InputSource.USER_COMMAND) returns trusted classification
- classifyInput('data', InputSource.NETWORK) returns untrusted classification
- sanitize() with invalid input throws ZodError
- sanitizeAndTrust() only returns TrustedInput after schema validation
</verification>

<success_criteria>
- Every input source correctly classified as trusted/untrusted (SEC-02)
- Zod validation required to promote untrusted -> trusted
- Branded types provide compile-time safety
- Runtime metadata tracks actual trust status
- Null byte and length attacks prevented by schemas
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-and-foundation/01-03-SUMMARY.md`
</output>
