---
phase: 01-security-and-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - pnpm-lock.yaml
  - tsconfig.json
  - src/types.ts
  - src/config/loader.ts
  - src/config/schema.ts
  - src/config/defaults.ts
  - src/config/index.ts
  - src/audit/logger.ts
  - src/audit/index.ts
  - .vec-permissionsrc.json
autonomous: true

must_haves:
  truths:
    - "Project compiles with tsc --noEmit without errors"
    - "Config loads from .vec-permissionsrc.json or returns defaults"
    - "Logger outputs structured JSON with sensitive field redaction"
  artifacts:
    - path: "package.json"
      provides: "Project manifest with all security dependencies"
      contains: "zod"
    - path: "tsconfig.json"
      provides: "TypeScript strict config"
      contains: "strict"
    - path: "src/config/schema.ts"
      provides: "Zod schemas for all config types"
      exports: ["PermissionConfigSchema", "PermissionRuleSchema"]
    - path: "src/config/loader.ts"
      provides: "Cosmiconfig-based config loading and saving"
      exports: ["loadConfig", "saveConfig"]
    - path: "src/audit/logger.ts"
      provides: "Pino logger with redaction"
      exports: ["logger", "createChildLogger"]
  key_links:
    - from: "src/config/loader.ts"
      to: "src/config/schema.ts"
      via: "Zod parse for validation"
      pattern: "PermissionConfigSchema\\.parse"
    - from: "src/audit/logger.ts"
      to: "pino"
      via: "Pino constructor with redact config"
      pattern: "pino\\("
---

<objective>
Scaffold the Vec TypeScript project and implement the config system and audit logger that all security modules depend on.

Purpose: Every security module (permission, validation, egress, monitoring) needs shared types, validated config, and structured logging. This plan creates that foundation.
Output: Compilable TypeScript project with config loading (cosmiconfig + Zod) and audit logging (Pino with redaction).
</objective>

<execution_context>
@/Users/enw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/enw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-and-foundation/01-RESEARCH.md
@.planning/phases/01-security-and-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project scaffolding and shared types</name>
  <files>package.json, tsconfig.json, src/types.ts</files>
  <action>
    1. Run `pnpm init` in project root
    2. Install dependencies: `pnpm add zod pino cosmiconfig fast-glob minimatch`
    3. Install dev dependencies: `pnpm add -D typescript @types/node @types/minimatch pino-pretty vitest`
    4. Create tsconfig.json:
       - strict: true, target: ES2022, module: Node16, moduleResolution: Node16
       - outDir: dist, rootDir: src
       - skipLibCheck: true, esModuleInterop: true
       - declaration: true
    5. Add to package.json: `"type": "module"`, scripts for build (`tsc`), test (`vitest`), typecheck (`tsc --noEmit`)
    6. Create src/types.ts with shared types used across all modules:
       - `TrustedInput` branded type (string & { __brand: 'trusted' })
       - `UntrustedInput` branded type (string & { __brand: 'untrusted' })
       - `InputSource` enum: USER_COMMAND, FILE_CONTENT, NETWORK, ENVIRONMENT
       - `PermissionAction` type: 'fs.read' | 'fs.write' | 'fs.delete' | 'egress.network' | 'egress.file'
       - `ScanResult` interface: { hasSecrets: boolean, findings: Array<{ type: string, line: number, match: string }> }
       - `TokenUsageEvent` interface: { model: string, promptTokens: number, completionTokens: number, totalTokens: number, timestamp: string }
    7. Create empty src/index.ts as barrel (will be populated in Plan 06)
  </action>
  <verify>Run `pnpm exec tsc --noEmit` -- must exit 0 with no errors</verify>
  <done>Project compiles, all deps installed, shared types exported from src/types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Config system with cosmiconfig + Zod validation</name>
  <files>src/config/schema.ts, src/config/defaults.ts, src/config/loader.ts, src/config/index.ts, .vec-permissionsrc.json</files>
  <action>
    1. Create src/config/schema.ts:
       - `PermissionActionSchema` = z.enum(['fs.read', 'fs.write', 'fs.delete', 'egress.network', 'egress.file'])
       - `PathPatternSchema` = z.string().min(1) with glob validation refinement
       - `VerbositySchema` = z.enum(['minimal', 'detailed', 'custom'])
       - `PermissionRuleSchema` = z.object({ id: z.string().uuid().optional(), action: PermissionActionSchema, pattern: PathPatternSchema, approved: z.boolean(), verbosity: VerbositySchema.default('minimal'), createdAt: z.string().datetime(), expiresAt: z.string().datetime().optional() })
       - `AuditConfigSchema` = z.object({ enabled: z.boolean().default(true), logPath: z.string().optional() })
       - `TokenBudgetSchema` = z.object({ limit: z.number().positive(), period: z.enum(['daily', 'weekly', 'monthly']), alertThresholds: z.array(z.number().min(0).max(1)).default([0.5, 0.7, 0.8, 1.0]) })
       - `PermissionConfigSchema` = z.object({ version: z.literal('1.0'), mode: z.enum(['strict', 'permissive']).default('strict'), rules: z.array(PermissionRuleSchema).default([]), audit: AuditConfigSchema.default({}), tokenBudget: TokenBudgetSchema.optional() })
       - Export inferred types: PermissionConfig, PermissionRule, TokenBudget, etc.
    2. Create src/config/defaults.ts:
       - Export `DEFAULT_CONFIG`: version '1.0', mode 'strict', empty rules, audit enabled, tokenBudget with 100000 limit daily and [0.5, 0.7, 0.8, 1.0] thresholds
    3. Create src/config/loader.ts:
       - `loadConfig()`: Use cosmiconfig('vec-permissions') to search for config. If not found or empty, return DEFAULT_CONFIG. Always validate with PermissionConfigSchema.parse()
       - `saveConfig(config)`: Validate then write to .vec-permissionsrc.json as formatted JSON
       - Handle errors: wrap in try/catch, log with console.error, return defaults on parse failure
    4. Create src/config/index.ts: re-export all from schema, defaults, loader
    5. Create .vec-permissionsrc.json with DEFAULT_CONFIG values as starter config
  </action>
  <verify>Run `pnpm exec tsc --noEmit` and verify config module compiles. Write a quick inline test: `import { loadConfig } from './src/config/loader.js'` loads without error</verify>
  <done>Config loads from disk via cosmiconfig, validates with Zod, falls back to defaults. Schemas exported for use by permission engine.</done>
</task>

<task type="auto">
  <name>Task 3: Audit logger with Pino and sensitive field redaction</name>
  <files>src/audit/logger.ts, src/audit/index.ts</files>
  <action>
    1. Create src/audit/logger.ts:
       - Create base Pino logger with level 'info'
       - Configure redaction paths: password, apiKey, api_key, token, access_token, refresh_token, authorization, cookie, secret, and wildcard variants (*.password, *.apiKey, *.token, *.secret)
       - Set censor to '[REDACTED]'
       - Use pino-pretty transport when NODE_ENV=development, raw JSON otherwise
       - Export `logger` (base instance)
       - Export `createChildLogger(component: string)` that returns logger.child({ component })
       - Export pre-built child loggers: `permissionLogger`, `egressLogger`, `validationLogger`, `monitorLogger`
       - Export `auditEvent(event: { type: string, action: string, target?: string, approved?: boolean, details?: Record<string, unknown> })` function that logs at 'warn' level with `audit: true` flag and ISO timestamp
    2. Create src/audit/index.ts: re-export all from logger
  </action>
  <verify>Run `pnpm exec tsc --noEmit`. Verify logger can be imported and creates child loggers without error.</verify>
  <done>Structured audit logger with automatic sensitive field redaction. Child loggers available for each security subsystem. auditEvent() provides consistent audit trail format.</done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit` passes with zero errors
- `pnpm test` framework runs (even if no tests yet)
- Config can be loaded: node -e "import('./dist/config/index.js').then(m => m.loadConfig().then(console.log))" after build
- Logger outputs JSON with redacted fields
</verification>

<success_criteria>
- TypeScript project compiles cleanly with strict mode
- All dependencies installed (zod, pino, cosmiconfig, fast-glob, minimatch)
- Config system loads, validates, saves permission rules
- Audit logger redacts sensitive fields automatically
- Shared types (TrustedInput, UntrustedInput, InputSource, etc.) available for downstream plans
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-and-foundation/01-01-SUMMARY.md`
</output>
