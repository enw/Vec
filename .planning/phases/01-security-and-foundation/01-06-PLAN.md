---
phase: 01-security-and-foundation
plan: 06
type: execute
wave: 3
depends_on: ["01-02", "01-03", "01-04", "01-05"]
files_modified:
  - src/index.ts
  - src/security.ts
  - tests/permission.test.ts
  - tests/validation.test.ts
  - tests/egress.test.ts
  - tests/monitoring.test.ts
  - tests/integration.test.ts
autonomous: true

must_haves:
  truths:
    - "All security modules importable from single entry point"
    - "Permission checks block operations without approval"
    - "Egress filter detects secrets in outbound data"
    - "Token tracker alerts at threshold"
    - "Input classifier distinguishes trusted from untrusted"
  artifacts:
    - path: "src/index.ts"
      provides: "Barrel export for all security modules"
      exports: ["PermissionEngine", "EgressFilter", "TokenTracker", "classifyInput"]
    - path: "src/security.ts"
      provides: "Unified security facade wiring all subsystems"
      exports: ["SecurityManager"]
    - path: "tests/integration.test.ts"
      provides: "End-to-end security flow tests"
      min_lines: 50
  key_links:
    - from: "src/security.ts"
      to: "src/permission/engine.ts"
      via: "creates and delegates to PermissionEngine"
      pattern: "new PermissionEngine"
    - from: "src/security.ts"
      to: "src/egress/filter.ts"
      via: "creates and delegates to EgressFilter"
      pattern: "new EgressFilter"
    - from: "src/security.ts"
      to: "src/monitoring/tracker.ts"
      via: "creates and delegates to TokenTracker"
      pattern: "(new TokenTracker|TokenTracker\\.create)"
    - from: "src/security.ts"
      to: "src/validation/classifier.ts"
      via: "exposes input classification"
      pattern: "classifyInput"
---

<objective>
Wire all security subsystems together, create unified facade, and write tests for all modules (SEC-01 through SEC-04 integration).

Purpose: Ensures all four security requirements work together as a cohesive system. The SecurityManager facade provides a single entry point for Phase 2+ to consume.
Output: Barrel exports, SecurityManager facade, and comprehensive test suite.
</objective>

<execution_context>
@/Users/enw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/enw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-and-foundation/01-01-SUMMARY.md
@.planning/phases/01-security-and-foundation/01-02-SUMMARY.md
@.planning/phases/01-security-and-foundation/01-03-SUMMARY.md
@.planning/phases/01-security-and-foundation/01-04-SUMMARY.md
@.planning/phases/01-security-and-foundation/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Security facade and barrel exports</name>
  <files>src/security.ts, src/index.ts</files>
  <action>
    1. Create src/security.ts -- unified SecurityManager facade:
       - `SecurityManager` class:
         - Constructor: `{ configPath?: string }` (optional path to config file)
         - Private fields: config, permissionEngine, egressFilter, tokenTracker, initialized (boolean)
         - `async init(): Promise<void>`
           a. Load config via loadConfig()
           b. Create PermissionEngine with config and default prompt
           c. Create EgressFilter with permissionEngine reference, mode from config
           d. Create TokenTracker from config.tokenBudget (if present)
           e. Set initialized = true
         - `async checkPermission(action: PermissionAction, target: string): Promise<boolean>`
           - Delegates to permissionEngine.check()
         - `async checkEgress(data: string, destination: string): Promise<{ allowed: boolean, findings: any[] }>`
           - Delegates to egressFilter.check()
         - `trackTokens(event: TokenUsageEvent): { alert: Alert | null, usage: any }`
           - Delegates to tokenTracker.track()
         - `classifyInput(input: string, source: InputSource): ClassifiedInput`
           - Delegates to validation/classifier
         - `getPermissionEngine(): PermissionEngine` -- direct access if needed
         - `getEgressFilter(): EgressFilter`
         - `getTokenTracker(): TokenTracker`
       - Export SecurityManager
    2. Update src/index.ts as barrel:
       - Re-export everything from config, permission, validation, egress, monitoring, audit
       - Re-export SecurityManager from security.ts
       - This is the public API of the security package
  </action>
  <verify>Run `pnpm exec tsc --noEmit`</verify>
  <done>SecurityManager wires all subsystems. Single import from src/index.ts provides full security API.</done>
</task>

<task type="auto">
  <name>Task 2: Test suite for all security modules</name>
  <files>tests/permission.test.ts, tests/validation.test.ts, tests/egress.test.ts, tests/monitoring.test.ts, tests/integration.test.ts, vitest.config.ts</files>
  <action>
    1. Create vitest.config.ts at project root:
       - import { defineConfig } from 'vitest/config'
       - test.include: ['tests/**/*.test.ts']
       - test.environment: 'node'
    2. Create tests/permission.test.ts:
       - Test matchRule: matching glob patterns, non-matching patterns, expired rules skipped
       - Test PermissionEngine with mock promptFn: auto-deny default, rule-based auto-approve, new rule creation on approval
       - Test PermissionDeniedError thrown by checkOrThrow
       - At least 5 test cases
    3. Create tests/validation.test.ts:
       - Test classifyInput: USER_COMMAND trusted, NETWORK untrusted
       - Test sanitize: valid input passes, invalid throws ZodError
       - Test sanitizeAndTrust: promotes untrusted to trusted after validation
       - Test schemas: UserCommandSchema rejects empty, FilePathSchema rejects null bytes
       - At least 5 test cases
    4. Create tests/egress.test.ts:
       - Test scanForSecrets: detects AWS keys, GitHub tokens, private keys, JWTs
       - Test hasHighEntropy: high entropy string detected, low entropy string passes
       - Test PII detection: emails, phone numbers
       - Test EgressFilter modes: 'block' blocks on findings, 'log-only' allows, 'warn' allows
       - At least 6 test cases
    5. Create tests/monitoring.test.ts:
       - Test BudgetManager: tracks usage, calculates percentage, resets on period expiry
       - Test AlertManager: fires alerts at thresholds, doesn't re-fire same threshold
       - Test TokenTracker: full tracking flow with alert callback
       - At least 5 test cases
    6. Create tests/integration.test.ts:
       - Test SecurityManager.init() creates all subsystems
       - Test full flow: classify input -> check permission -> scan egress -> track tokens
       - Test: data with secret blocked by egress, clean data allowed
       - Test: permission denied without rule, allowed with matching rule
       - At least 4 test cases
  </action>
  <verify>Run `pnpm test` -- all tests must pass. Run `pnpm exec tsc --noEmit` -- type check passes.</verify>
  <done>25+ tests covering all four security requirements. All pass. SecurityManager integrates all subsystems correctly.</done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit` passes (full project type check)
- `pnpm test` passes (all 25+ tests green)
- `import { SecurityManager } from './src/index.js'` resolves all exports
- No circular dependencies between modules
</verification>

<success_criteria>
- SecurityManager facade provides single entry point for all security operations
- Barrel export (src/index.ts) exposes complete public API
- Test coverage for all four requirements:
  - SEC-01: Permission engine blocks without approval, hybrid flow works
  - SEC-02: Input classified by source, validation promotes trust
  - SEC-03: Egress filter detects secrets and PII, blocks in strict mode
  - SEC-04: Token tracker alerts at thresholds, budget resets by period
- All tests pass with `pnpm test`
- Ready for Phase 2 consumption
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-and-foundation/01-06-SUMMARY.md`
</output>
