---
phase: 03-memory-system
plan: 04
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - src/memory/MessageSummarizer.ts
  - src/memory/summarize-worker.ts
  - src/memory/HeartbeatManager.ts
  - src/memory/index.ts
autonomous: true

must_haves:
  truths:
    - "Summarization triggers proactively when conversation exceeds 80% of token limit"
    - "Old messages are replaced with summaries, preserving context"
    - "Summarization runs in background Worker Thread without blocking conversation"
    - "HEARTBEAT.md reflects current task status (idle/active/completed)"
  artifacts:
    - path: "src/memory/MessageSummarizer.ts"
      provides: "Background summarization orchestrator"
      exports: ["MessageSummarizer"]
    - path: "src/memory/summarize-worker.ts"
      provides: "Worker Thread script for summarization"
    - path: "src/memory/HeartbeatManager.ts"
      provides: "HEARTBEAT.md lifecycle management"
      exports: ["HeartbeatManager"]
  key_links:
    - from: "src/memory/MessageSummarizer.ts"
      to: "src/memory/summarize-worker.ts"
      via: "Worker Thread spawn"
      pattern: "new Worker"
    - from: "src/memory/MessageSummarizer.ts"
      to: "src/memory/TokenAwareLoader.ts"
      via: "shouldSummarize() check"
      pattern: "shouldSummarize"
---

<objective>
Create background summarization with Worker Threads and HEARTBEAT.md lifecycle management. When conversation approaches 80% of token limit, old messages are summarized and replaced proactively.

Purpose: Without summarization, conversations hit the 100k token wall and can't continue. Proactive summarization (user decision) prevents latency during conversation. HEARTBEAT.md tracks what the agent is doing.
Output: MessageSummarizer (background worker), HeartbeatManager.
</objective>

<execution_context>
@/Users/enw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/enw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-memory-system/03-CONTEXT.md
@.planning/phases/03-memory-system/03-RESEARCH.md
@.planning/phases/03-memory-system/03-02-SUMMARY.md
@src/workspace/ConversationStore.ts
@src/llm/AnthropicClient.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: MessageSummarizer with Worker Thread</name>
  <files>
    src/memory/MessageSummarizer.ts
    src/memory/summarize-worker.ts
  </files>
  <action>
    1. Create `src/memory/summarize-worker.ts` (runs in Worker Thread):
       - Receives workerData: `{ workspacePath: string; model?: string; apiKey?: string; baseURL?: string; defaultHeaders?: Record<string, string> }`
       - Creates AnthropicClient from provided config
       - Loads all messages from conversation.jsonl
       - Splits messages into two groups:
         - **Old messages** (first 60% of messages by count) - candidates for summarization
         - **Recent messages** (last 40%) - keep verbatim
       - Sends old messages to LLM with prompt:
         ```
         Summarize the following conversation history. Preserve:
         - Key decisions and their reasoning
         - Important facts and context
         - Action items and commitments
         - User preferences expressed
         Format as a concise narrative summary.
         ```
       - Creates a summary message: `{ id: uuid, role: 'assistant', content: '[Summary of earlier conversation]\n\n{summary}', timestamp: Date.now(), isSummary: true }`
       - Rewrites conversation.jsonl: summary message + recent messages (using write-file-atomic)
       - Posts result to parent: `{ success: boolean; reducedTokens: number; error?: string }`

    2. Create `src/memory/MessageSummarizer.ts`:
       - Class `MessageSummarizer`
       - Constructor takes `{ tokenAwareLoader: TokenAwareLoader; workspacePath: string; clientConfig: { apiKey?: string; baseURL?: string; defaultHeaders?: Record<string, string> } }`
       - Private `running: boolean` to prevent concurrent summarization
       - `async checkAndSummarize(): Promise<void>`
         - If already running, return immediately
         - Call tokenAwareLoader.shouldSummarize()
         - If false, return
         - Set running = true
         - Spawn Worker Thread with `new Worker(fileURLToPath(new URL('./summarize-worker.js', import.meta.url)), { workerData: {...} })`
         - Listen for 'message' (success) and 'error' (failure)
         - Set running = false on completion
         - Log result (tokens reduced, any errors)
       - `isRunning(): boolean` - returns current state
       - Note: Worker path must point to compiled .js file, not .ts

    3. Add `isSummary?: boolean` to the Message type in `src/workspace/types.ts` (marks summary messages for display differentiation).

    4. Update `src/memory/index.ts` to re-export MessageSummarizer.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Unit test: mock worker, verify checkAndSummarize only runs when shouldSummarize returns true
    - Unit test: verify concurrent calls are prevented (running flag)
    - Integration test: create 50 messages, trigger summarization, verify conversation.jsonl rewritten with summary + recent messages
  </verify>
  <done>Background summarization replaces old messages with summaries when >80% of token budget used. Worker Thread prevents blocking main conversation.</done>
</task>

<task type="auto">
  <name>Task 2: HeartbeatManager for task status tracking</name>
  <files>
    src/memory/HeartbeatManager.ts
    src/memory/index.ts
  </files>
  <action>
    1. Create `src/memory/HeartbeatManager.ts`:
       - Class `HeartbeatManager`
       - Constructor takes `{ profileManager: ProfileManager; workspaceName: string }`
       - `async startTask(description: string): Promise<void>`
         - Loads HEARTBEAT.md, updates: status='active', current_task=description, started_at=ISO timestamp, last_checkin=ISO timestamp
         - Saves via profileManager.saveProfile
       - `async checkin(): Promise<void>`
         - If status is 'active', updates last_checkin to now
         - Saves via profileManager.saveProfile
       - `async completeTask(): Promise<void>`
         - Updates: status='completed', clears current_task, clears started_at, sets last_checkin
         - Saves via profileManager.saveProfile
       - `async reset(): Promise<void>`
         - Sets status='idle', clears all fields
         - Saves via profileManager.saveProfile
       - `async getStatus(): Promise<HeartbeatProfile>`
         - Loads and returns current heartbeat data

    Per user decision: HEARTBEAT.md is ephemeral status of current task, NOT a log/journal. Updates at start/end of task + periodic check-ins.

    Per user decision on Claude's discretion (when to write profiles): Write on every status change for HEARTBEAT.md specifically, since it's ephemeral status that must survive crashes. Other profiles will write per-turn (decided in Plan 03).

    2. Update `src/memory/index.ts` to re-export HeartbeatManager.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Unit test: startTask -> getStatus shows active with task description
    - Unit test: completeTask -> getStatus shows completed, no current_task
    - Unit test: reset -> getStatus shows idle
  </verify>
  <done>HeartbeatManager tracks current task status in HEARTBEAT.md with start/checkin/complete lifecycle</done>
</task>

</tasks>

<verification>
- Summarization triggers at 80% of 100k tokens (80k threshold)
- Old messages replaced with summary, recent messages preserved
- Worker Thread runs without blocking main process
- HEARTBEAT.md lifecycle: idle -> active -> completed -> idle
- Concurrent summarization prevented
- `pnpm build` succeeds
</verification>

<success_criteria>
- Proactive summarization as background task (user decision honored)
- Token limit hardcoded at 100k (user decision honored)
- HEARTBEAT.md tracks single current task (not a log - user decision honored)
- Worker Thread approach (not BullMQ - per research recommendation for simpler start)
</success_criteria>

<output>
After completion, create `.planning/phases/03-memory-system/03-04-SUMMARY.md`
</output>
